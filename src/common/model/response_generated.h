// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESPONSE_SPT_CONFIGDB_MODEL_H_
#define FLATBUFFERS_GENERATED_RESPONSE_SPT_CONFIGDB_MODEL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace spt {
namespace configdb {
namespace model {

struct Value;
struct ValueBuilder;

struct Children;
struct ChildrenBuilder;

struct Success;
struct SuccessBuilder;

struct KeyValueResult;
struct KeyValueResultBuilder;

struct KeyValueResults;
struct KeyValueResultsBuilder;

struct Response;
struct ResponseBuilder;

inline const ::flatbuffers::TypeTable *ValueTypeTable();

inline const ::flatbuffers::TypeTable *ChildrenTypeTable();

inline const ::flatbuffers::TypeTable *SuccessTypeTable();

inline const ::flatbuffers::TypeTable *KeyValueResultTypeTable();

inline const ::flatbuffers::TypeTable *KeyValueResultsTypeTable();

inline const ::flatbuffers::TypeTable *ResponseTypeTable();

enum class ValueVariant : uint8_t {
  NONE = 0,
  Value = 1,
  Children = 2,
  Success = 3,
  MIN = NONE,
  MAX = Success
};

inline const ValueVariant (&EnumValuesValueVariant())[4] {
  static const ValueVariant values[] = {
    ValueVariant::NONE,
    ValueVariant::Value,
    ValueVariant::Children,
    ValueVariant::Success
  };
  return values;
}

inline const char * const *EnumNamesValueVariant() {
  static const char * const names[5] = {
    "NONE",
    "Value",
    "Children",
    "Success",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueVariant(ValueVariant e) {
  if (::flatbuffers::IsOutRange(e, ValueVariant::NONE, ValueVariant::Success)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValueVariant()[index];
}

template<typename T> struct ValueVariantTraits {
  static const ValueVariant enum_value = ValueVariant::NONE;
};

template<> struct ValueVariantTraits<spt::configdb::model::Value> {
  static const ValueVariant enum_value = ValueVariant::Value;
};

template<> struct ValueVariantTraits<spt::configdb::model::Children> {
  static const ValueVariant enum_value = ValueVariant::Children;
};

template<> struct ValueVariantTraits<spt::configdb::model::Success> {
  static const ValueVariant enum_value = ValueVariant::Success;
};

bool VerifyValueVariant(::flatbuffers::Verifier &verifier, const void *obj, ValueVariant type);
bool VerifyValueVariantVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueVariant> *types);

enum class ResultVariant : uint8_t {
  NONE = 0,
  KeyValueResults = 1,
  Success = 2,
  MIN = NONE,
  MAX = Success
};

inline const ResultVariant (&EnumValuesResultVariant())[3] {
  static const ResultVariant values[] = {
    ResultVariant::NONE,
    ResultVariant::KeyValueResults,
    ResultVariant::Success
  };
  return values;
}

inline const char * const *EnumNamesResultVariant() {
  static const char * const names[4] = {
    "NONE",
    "KeyValueResults",
    "Success",
    nullptr
  };
  return names;
}

inline const char *EnumNameResultVariant(ResultVariant e) {
  if (::flatbuffers::IsOutRange(e, ResultVariant::NONE, ResultVariant::Success)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResultVariant()[index];
}

template<typename T> struct ResultVariantTraits {
  static const ResultVariant enum_value = ResultVariant::NONE;
};

template<> struct ResultVariantTraits<spt::configdb::model::KeyValueResults> {
  static const ResultVariant enum_value = ResultVariant::KeyValueResults;
};

template<> struct ResultVariantTraits<spt::configdb::model::Success> {
  static const ResultVariant enum_value = ResultVariant::Success;
};

bool VerifyResultVariant(::flatbuffers::Verifier &verifier, const void *obj, ResultVariant type);
bool VerifyResultVariantVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ResultVariant> *types);

struct Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ValueTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != -1, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct ValueBuilder {
  typedef Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(Value::VT_VALUE, value);
  }
  explicit ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Value> CreateValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Value::Traits {
  using type = Value;
  static auto constexpr Create = CreateValue;
  static constexpr auto name = "Value";
  static constexpr auto fully_qualified_name = "spt.configdb.model.Value";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Value> CreateValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return spt::configdb::model::CreateValue(
      _fbb,
      value__);
}

struct Children FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChildrenBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChildrenTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *value() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != -1, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.VerifyVectorOfStrings(value()) &&
           verifier.EndTable();
  }
};

struct ChildrenBuilder {
  typedef Children Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> value) {
    fbb_.AddOffset(Children::VT_VALUE, value);
  }
  explicit ChildrenBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Children> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Children>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Children> CreateChildren(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> value = 0) {
  ChildrenBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Children::Traits {
  using type = Children;
  static auto constexpr Create = CreateChildren;
  static constexpr auto name = "Children";
  static constexpr auto fully_qualified_name = "spt.configdb.model.Children";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Children> CreateChildrenDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*value) : 0;
  return spt::configdb::model::CreateChildren(
      _fbb,
      value__);
}

struct Success FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SuccessBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SuccessTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != -1, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct SuccessBuilder {
  typedef Success Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(Success::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit SuccessBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Success> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Success>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Success> CreateSuccess(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  SuccessBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Success::Traits {
  using type = Success;
  static auto constexpr Create = CreateSuccess;
  static constexpr auto name = "Success";
  static constexpr auto fully_qualified_name = "spt.configdb.model.Success";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct KeyValueResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyValueResultBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KeyValueResultTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  spt::configdb::model::ValueVariant value_type() const {
    return static_cast<spt::configdb::model::ValueVariant>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const spt::configdb::model::Value *value_as_Value() const {
    return value_type() == spt::configdb::model::ValueVariant::Value ? static_cast<const spt::configdb::model::Value *>(value()) : nullptr;
  }
  const spt::configdb::model::Children *value_as_Children() const {
    return value_type() == spt::configdb::model::ValueVariant::Children ? static_cast<const spt::configdb::model::Children *>(value()) : nullptr;
  }
  const spt::configdb::model::Success *value_as_Success() const {
    return value_type() == spt::configdb::model::ValueVariant::Success ? static_cast<const spt::configdb::model::Success *>(value()) : nullptr;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return key();
    else if constexpr (Index == 1) return value_type();
    else if constexpr (Index == 2) return value();
    else static_assert(Index != -1, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueVariant(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const spt::configdb::model::Value *KeyValueResult::value_as<spt::configdb::model::Value>() const {
  return value_as_Value();
}

template<> inline const spt::configdb::model::Children *KeyValueResult::value_as<spt::configdb::model::Children>() const {
  return value_as_Children();
}

template<> inline const spt::configdb::model::Success *KeyValueResult::value_as<spt::configdb::model::Success>() const {
  return value_as_Success();
}

struct KeyValueResultBuilder {
  typedef KeyValueResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(KeyValueResult::VT_KEY, key);
  }
  void add_value_type(spt::configdb::model::ValueVariant value_type) {
    fbb_.AddElement<uint8_t>(KeyValueResult::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(KeyValueResult::VT_VALUE, value);
  }
  explicit KeyValueResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyValueResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyValueResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyValueResult> CreateKeyValueResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    spt::configdb::model::ValueVariant value_type = spt::configdb::model::ValueVariant::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  KeyValueResultBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct KeyValueResult::Traits {
  using type = KeyValueResult;
  static auto constexpr Create = CreateKeyValueResult;
  static constexpr auto name = "KeyValueResult";
  static constexpr auto fully_qualified_name = "spt.configdb.model.KeyValueResult";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "key",
    "value_type",
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<KeyValueResult> CreateKeyValueResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    spt::configdb::model::ValueVariant value_type = spt::configdb::model::ValueVariant::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return spt::configdb::model::CreateKeyValueResult(
      _fbb,
      key__,
      value_type,
      value);
}

struct KeyValueResults FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyValueResultsBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KeyValueResultsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<spt::configdb::model::KeyValueResult>> *value() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<spt::configdb::model::KeyValueResult>> *>(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != -1, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.VerifyVectorOfTables(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueResultsBuilder {
  typedef KeyValueResults Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<spt::configdb::model::KeyValueResult>>> value) {
    fbb_.AddOffset(KeyValueResults::VT_VALUE, value);
  }
  explicit KeyValueResultsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyValueResults> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyValueResults>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyValueResults> CreateKeyValueResults(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<spt::configdb::model::KeyValueResult>>> value = 0) {
  KeyValueResultsBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct KeyValueResults::Traits {
  using type = KeyValueResults;
  static auto constexpr Create = CreateKeyValueResults;
  static constexpr auto name = "KeyValueResults";
  static constexpr auto fully_qualified_name = "spt.configdb.model.KeyValueResults";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<KeyValueResults> CreateKeyValueResultsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<spt::configdb::model::KeyValueResult>> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<::flatbuffers::Offset<spt::configdb::model::KeyValueResult>>(*value) : 0;
  return spt::configdb::model::CreateKeyValueResults(
      _fbb,
      value__);
}

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  spt::configdb::model::ResultVariant value_type() const {
    return static_cast<spt::configdb::model::ResultVariant>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const spt::configdb::model::KeyValueResults *value_as_KeyValueResults() const {
    return value_type() == spt::configdb::model::ResultVariant::KeyValueResults ? static_cast<const spt::configdb::model::KeyValueResults *>(value()) : nullptr;
  }
  const spt::configdb::model::Success *value_as_Success() const {
    return value_type() == spt::configdb::model::ResultVariant::Success ? static_cast<const spt::configdb::model::Success *>(value()) : nullptr;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value_type();
    else if constexpr (Index == 1) return value();
    else static_assert(Index != -1, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyResultVariant(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const spt::configdb::model::KeyValueResults *Response::value_as<spt::configdb::model::KeyValueResults>() const {
  return value_as_KeyValueResults();
}

template<> inline const spt::configdb::model::Success *Response::value_as<spt::configdb::model::Success>() const {
  return value_as_Success();
}

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_type(spt::configdb::model::ResultVariant value_type) {
    fbb_.AddElement<uint8_t>(Response::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Response::VT_VALUE, value);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    spt::configdb::model::ResultVariant value_type = spt::configdb::model::ResultVariant::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct Response::Traits {
  using type = Response;
  static auto constexpr Create = CreateResponse;
  static constexpr auto name = "Response";
  static constexpr auto fully_qualified_name = "spt.configdb.model.Response";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value_type",
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline bool VerifyValueVariant(::flatbuffers::Verifier &verifier, const void *obj, ValueVariant type) {
  switch (type) {
    case ValueVariant::NONE: {
      return true;
    }
    case ValueVariant::Value: {
      auto ptr = reinterpret_cast<const spt::configdb::model::Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueVariant::Children: {
      auto ptr = reinterpret_cast<const spt::configdb::model::Children *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueVariant::Success: {
      auto ptr = reinterpret_cast<const spt::configdb::model::Success *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVariantVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueVariant> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValueVariant(
        verifier,  values->Get(i), types->GetEnum<ValueVariant>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResultVariant(::flatbuffers::Verifier &verifier, const void *obj, ResultVariant type) {
  switch (type) {
    case ResultVariant::NONE: {
      return true;
    }
    case ResultVariant::KeyValueResults: {
      auto ptr = reinterpret_cast<const spt::configdb::model::KeyValueResults *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResultVariant::Success: {
      auto ptr = reinterpret_cast<const spt::configdb::model::Success *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResultVariantVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ResultVariant> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResultVariant(
        verifier,  values->Get(i), types->GetEnum<ResultVariant>(i))) {
      return false;
    }
  }
  return true;
}

inline const ::flatbuffers::TypeTable *ValueVariantTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    spt::configdb::model::ValueTypeTable,
    spt::configdb::model::ChildrenTypeTable,
    spt::configdb::model::SuccessTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Value",
    "Children",
    "Success"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ResultVariantTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    spt::configdb::model::KeyValueResultsTypeTable,
    spt::configdb::model::SuccessTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "KeyValueResults",
    "Success"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ValueTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ChildrenTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SuccessTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *KeyValueResultTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    spt::configdb::model::ValueVariantTypeTable
  };
  static const char * const names[] = {
    "key",
    "value_type",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *KeyValueResultsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    spt::configdb::model::KeyValueResultTypeTable
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    spt::configdb::model::ResultVariantTypeTable
  };
  static const char * const names[] = {
    "value_type",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const spt::configdb::model::Response *GetResponse(const void *buf) {
  return ::flatbuffers::GetRoot<spt::configdb::model::Response>(buf);
}

inline const spt::configdb::model::Response *GetSizePrefixedResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<spt::configdb::model::Response>(buf);
}

inline bool VerifyResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<spt::configdb::model::Response>(nullptr);
}

inline bool VerifySizePrefixedResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<spt::configdb::model::Response>(nullptr);
}

inline void FinishResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<spt::configdb::model::Response> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<spt::configdb::model::Response> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace model
}  // namespace configdb
}  // namespace spt

#endif  // FLATBUFFERS_GENERATED_RESPONSE_SPT_CONFIGDB_MODEL_H_
